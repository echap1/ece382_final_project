#![doc = "Peripheral access API for MSP432P401R microcontrollers (generated using svd2rust v0.34.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.34.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn PSS_IRQ();
    fn CS_IRQ();
    fn PCM_IRQ();
    fn WDT_A_IRQ();
    fn FPU_IRQ();
    fn FLCTL_IRQ();
    fn COMP_E0_IRQ();
    fn COMP_E1_IRQ();
    fn TA0_0_IRQ();
    fn TA0_N_IRQ();
    fn TA1_0_IRQ();
    fn TA1_N_IRQ();
    fn TA2_0_IRQ();
    fn TA2_N_IRQ();
    fn TA3_0_IRQ();
    fn TA3_N_IRQ();
    fn EUSCIA0_IRQ();
    fn EUSCIA1_IRQ();
    fn EUSCIA2_IRQ();
    fn EUSCIA3_IRQ();
    fn EUSCIB0_IRQ();
    fn EUSCIB1_IRQ();
    fn EUSCIB2_IRQ();
    fn EUSCIB3_IRQ();
    fn ADC14_IRQ();
    fn T32_INT1_IRQ();
    fn T32_INT2_IRQ();
    fn T32_INTC_IRQ();
    fn AES256_IRQ();
    fn RTC_C_IRQ();
    fn DMA_ERR_IRQ();
    fn DMA_INT3_IRQ();
    fn DMA_INT2_IRQ();
    fn DMA_INT1_IRQ();
    fn DMA_INT0_IRQ();
    fn PORT1_IRQ();
    fn PORT2_IRQ();
    fn PORT3_IRQ();
    fn PORT4_IRQ();
    fn PORT5_IRQ();
    fn PORT6_IRQ();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 41] = [
    Vector { _handler: PSS_IRQ },
    Vector { _handler: CS_IRQ },
    Vector { _handler: PCM_IRQ },
    Vector {
        _handler: WDT_A_IRQ,
    },
    Vector { _handler: FPU_IRQ },
    Vector {
        _handler: FLCTL_IRQ,
    },
    Vector {
        _handler: COMP_E0_IRQ,
    },
    Vector {
        _handler: COMP_E1_IRQ,
    },
    Vector {
        _handler: TA0_0_IRQ,
    },
    Vector {
        _handler: TA0_N_IRQ,
    },
    Vector {
        _handler: TA1_0_IRQ,
    },
    Vector {
        _handler: TA1_N_IRQ,
    },
    Vector {
        _handler: TA2_0_IRQ,
    },
    Vector {
        _handler: TA2_N_IRQ,
    },
    Vector {
        _handler: TA3_0_IRQ,
    },
    Vector {
        _handler: TA3_N_IRQ,
    },
    Vector {
        _handler: EUSCIA0_IRQ,
    },
    Vector {
        _handler: EUSCIA1_IRQ,
    },
    Vector {
        _handler: EUSCIA2_IRQ,
    },
    Vector {
        _handler: EUSCIA3_IRQ,
    },
    Vector {
        _handler: EUSCIB0_IRQ,
    },
    Vector {
        _handler: EUSCIB1_IRQ,
    },
    Vector {
        _handler: EUSCIB2_IRQ,
    },
    Vector {
        _handler: EUSCIB3_IRQ,
    },
    Vector {
        _handler: ADC14_IRQ,
    },
    Vector {
        _handler: T32_INT1_IRQ,
    },
    Vector {
        _handler: T32_INT2_IRQ,
    },
    Vector {
        _handler: T32_INTC_IRQ,
    },
    Vector {
        _handler: AES256_IRQ,
    },
    Vector {
        _handler: RTC_C_IRQ,
    },
    Vector {
        _handler: DMA_ERR_IRQ,
    },
    Vector {
        _handler: DMA_INT3_IRQ,
    },
    Vector {
        _handler: DMA_INT2_IRQ,
    },
    Vector {
        _handler: DMA_INT1_IRQ,
    },
    Vector {
        _handler: DMA_INT0_IRQ,
    },
    Vector {
        _handler: PORT1_IRQ,
    },
    Vector {
        _handler: PORT2_IRQ,
    },
    Vector {
        _handler: PORT3_IRQ,
    },
    Vector {
        _handler: PORT4_IRQ,
    },
    Vector {
        _handler: PORT5_IRQ,
    },
    Vector {
        _handler: PORT6_IRQ,
    },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - PSS Interrupt"]
    PSS_IRQ = 0,
    #[doc = "1 - CS Interrupt"]
    CS_IRQ = 1,
    #[doc = "2 - PCM Interrupt"]
    PCM_IRQ = 2,
    #[doc = "3 - WDT_A Interrupt"]
    WDT_A_IRQ = 3,
    #[doc = "4 - FPU Interrupt"]
    FPU_IRQ = 4,
    #[doc = "5 - Flash Controller Interrupt"]
    FLCTL_IRQ = 5,
    #[doc = "6 - COMP_E0 Interrupt"]
    COMP_E0_IRQ = 6,
    #[doc = "7 - COMP_E1 Interrupt"]
    COMP_E1_IRQ = 7,
    #[doc = "8 - TA0_0 Interrupt"]
    TA0_0_IRQ = 8,
    #[doc = "9 - TA0_N Interrupt"]
    TA0_N_IRQ = 9,
    #[doc = "10 - TA1_0 Interrupt"]
    TA1_0_IRQ = 10,
    #[doc = "11 - TA1_N Interrupt"]
    TA1_N_IRQ = 11,
    #[doc = "12 - TA2_0 Interrupt"]
    TA2_0_IRQ = 12,
    #[doc = "13 - TA2_N Interrupt"]
    TA2_N_IRQ = 13,
    #[doc = "14 - TA3_0 Interrupt"]
    TA3_0_IRQ = 14,
    #[doc = "15 - TA3_N Interrupt"]
    TA3_N_IRQ = 15,
    #[doc = "16 - EUSCIA0 Interrupt"]
    EUSCIA0_IRQ = 16,
    #[doc = "17 - EUSCIA1 Interrupt"]
    EUSCIA1_IRQ = 17,
    #[doc = "18 - EUSCIA2 Interrupt"]
    EUSCIA2_IRQ = 18,
    #[doc = "19 - EUSCIA3 Interrupt"]
    EUSCIA3_IRQ = 19,
    #[doc = "20 - EUSCIB0 Interrupt"]
    EUSCIB0_IRQ = 20,
    #[doc = "21 - EUSCIB1 Interrupt"]
    EUSCIB1_IRQ = 21,
    #[doc = "22 - EUSCIB2 Interrupt"]
    EUSCIB2_IRQ = 22,
    #[doc = "23 - EUSCIB3 Interrupt"]
    EUSCIB3_IRQ = 23,
    #[doc = "24 - ADC14 Interrupt"]
    ADC14_IRQ = 24,
    #[doc = "25 - T32_INT1 Interrupt"]
    T32_INT1_IRQ = 25,
    #[doc = "26 - T32_INT2 Interrupt"]
    T32_INT2_IRQ = 26,
    #[doc = "27 - T32_INTC Interrupt"]
    T32_INTC_IRQ = 27,
    #[doc = "28 - AES256 Interrupt"]
    AES256_IRQ = 28,
    #[doc = "29 - RTC_C Interrupt"]
    RTC_C_IRQ = 29,
    #[doc = "30 - DMA_ERR Interrupt"]
    DMA_ERR_IRQ = 30,
    #[doc = "31 - DMA_INT3 Interrupt"]
    DMA_INT3_IRQ = 31,
    #[doc = "32 - DMA_INT2 Interrupt"]
    DMA_INT2_IRQ = 32,
    #[doc = "33 - DMA_INT1 Interrupt"]
    DMA_INT1_IRQ = 33,
    #[doc = "34 - DMA_INT0 Interrupt"]
    DMA_INT0_IRQ = 34,
    #[doc = "35 - Port1 Interrupt"]
    PORT1_IRQ = 35,
    #[doc = "36 - Port2 Interrupt"]
    PORT2_IRQ = 36,
    #[doc = "37 - Port3 Interrupt"]
    PORT3_IRQ = 37,
    #[doc = "38 - Port4 Interrupt"]
    PORT4_IRQ = 38,
    #[doc = "39 - Port5 Interrupt"]
    PORT5_IRQ = 39,
    #[doc = "40 - Port6 Interrupt"]
    PORT6_IRQ = 40,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "TLV"]
pub struct Tlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tlv {}
impl Tlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tlv::RegisterBlock = 0x0020_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tlv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tlv {
    type Target = tlv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tlv").finish()
    }
}
#[doc = "TLV"]
pub mod tlv;
#[doc = "TIMER_A0"]
pub struct TimerA0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TimerA0 {}
impl TimerA0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer_a0::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer_a0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TimerA0 {
    type Target = timer_a0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TimerA0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TimerA0").finish()
    }
}
#[doc = "TIMER_A0"]
pub mod timer_a0;
#[doc = "TIMER_A1"]
pub struct TimerA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TimerA1 {}
impl TimerA1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer_a1::RegisterBlock = 0x4000_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer_a1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TimerA1 {
    type Target = timer_a1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TimerA1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TimerA1").finish()
    }
}
#[doc = "TIMER_A1"]
pub mod timer_a1;
#[doc = "TIMER_A2"]
pub struct TimerA2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TimerA2 {}
impl TimerA2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer_a2::RegisterBlock = 0x4000_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer_a2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TimerA2 {
    type Target = timer_a2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TimerA2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TimerA2").finish()
    }
}
#[doc = "TIMER_A2"]
pub mod timer_a2;
#[doc = "TIMER_A3"]
pub struct TimerA3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TimerA3 {}
impl TimerA3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer_a3::RegisterBlock = 0x4000_0c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer_a3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TimerA3 {
    type Target = timer_a3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TimerA3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TimerA3").finish()
    }
}
#[doc = "TIMER_A3"]
pub mod timer_a3;
#[doc = "EUSCI_A0"]
pub struct EusciA0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EusciA0 {}
impl EusciA0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusci_a0::RegisterBlock = 0x4000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusci_a0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EusciA0 {
    type Target = eusci_a0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EusciA0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EusciA0").finish()
    }
}
#[doc = "EUSCI_A0"]
pub mod eusci_a0;
#[doc = "EUSCI_A1"]
pub struct EusciA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EusciA1 {}
impl EusciA1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusci_a1::RegisterBlock = 0x4000_1400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusci_a1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EusciA1 {
    type Target = eusci_a1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EusciA1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EusciA1").finish()
    }
}
#[doc = "EUSCI_A1"]
pub mod eusci_a1;
#[doc = "EUSCI_A2"]
pub struct EusciA2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EusciA2 {}
impl EusciA2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusci_a2::RegisterBlock = 0x4000_1800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusci_a2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EusciA2 {
    type Target = eusci_a2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EusciA2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EusciA2").finish()
    }
}
#[doc = "EUSCI_A2"]
pub mod eusci_a2;
#[doc = "EUSCI_A3"]
pub struct EusciA3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EusciA3 {}
impl EusciA3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusci_a3::RegisterBlock = 0x4000_1c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusci_a3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EusciA3 {
    type Target = eusci_a3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EusciA3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EusciA3").finish()
    }
}
#[doc = "EUSCI_A3"]
pub mod eusci_a3;
#[doc = "EUSCI_B0"]
pub struct EusciB0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EusciB0 {}
impl EusciB0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusci_b0::RegisterBlock = 0x4000_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusci_b0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EusciB0 {
    type Target = eusci_b0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EusciB0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EusciB0").finish()
    }
}
#[doc = "EUSCI_B0"]
pub mod eusci_b0;
#[doc = "EUSCI_B1"]
pub struct EusciB1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EusciB1 {}
impl EusciB1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusci_b1::RegisterBlock = 0x4000_2400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusci_b1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EusciB1 {
    type Target = eusci_b1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EusciB1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EusciB1").finish()
    }
}
#[doc = "EUSCI_B1"]
pub mod eusci_b1;
#[doc = "EUSCI_B2"]
pub struct EusciB2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EusciB2 {}
impl EusciB2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusci_b2::RegisterBlock = 0x4000_2800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusci_b2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EusciB2 {
    type Target = eusci_b2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EusciB2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EusciB2").finish()
    }
}
#[doc = "EUSCI_B2"]
pub mod eusci_b2;
#[doc = "EUSCI_B3"]
pub struct EusciB3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EusciB3 {}
impl EusciB3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusci_b3::RegisterBlock = 0x4000_2c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusci_b3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EusciB3 {
    type Target = eusci_b3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EusciB3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EusciB3").finish()
    }
}
#[doc = "EUSCI_B3"]
pub mod eusci_b3;
#[doc = "REF_A"]
pub struct RefA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RefA {}
impl RefA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ref_a::RegisterBlock = 0x4000_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ref_a::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RefA {
    type Target = ref_a::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RefA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RefA").finish()
    }
}
#[doc = "REF_A"]
pub mod ref_a;
#[doc = "COMP_E0"]
pub struct CompE0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CompE0 {}
impl CompE0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const comp_e0::RegisterBlock = 0x4000_3400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const comp_e0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CompE0 {
    type Target = comp_e0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CompE0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CompE0").finish()
    }
}
#[doc = "COMP_E0"]
pub mod comp_e0;
#[doc = "COMP_E1"]
pub struct CompE1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CompE1 {}
impl CompE1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const comp_e1::RegisterBlock = 0x4000_3800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const comp_e1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CompE1 {
    type Target = comp_e1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CompE1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CompE1").finish()
    }
}
#[doc = "COMP_E1"]
pub mod comp_e1;
#[doc = "AES256"]
pub struct Aes256 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Aes256 {}
impl Aes256 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aes256::RegisterBlock = 0x4000_3c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aes256::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Aes256 {
    type Target = aes256::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Aes256 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Aes256").finish()
    }
}
#[doc = "AES256"]
pub mod aes256;
#[doc = "CRC32"]
pub struct Crc32 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Crc32 {}
impl Crc32 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crc32::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crc32::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Crc32 {
    type Target = crc32::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Crc32 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crc32").finish()
    }
}
#[doc = "CRC32"]
pub mod crc32;
#[doc = "RTC_C"]
pub struct RtcC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RtcC {}
impl RtcC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc_c::RegisterBlock = 0x4000_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc_c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RtcC {
    type Target = rtc_c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RtcC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RtcC").finish()
    }
}
#[doc = "RTC_C"]
pub mod rtc_c;
#[doc = "WDT_A"]
pub struct WdtA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WdtA {}
impl WdtA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt_a::RegisterBlock = 0x4000_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt_a::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for WdtA {
    type Target = wdt_a::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WdtA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WdtA").finish()
    }
}
#[doc = "WDT_A"]
pub mod wdt_a;
#[doc = "DIO"]
pub struct Dio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dio {}
impl Dio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dio::RegisterBlock = 0x4000_4c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dio {
    type Target = dio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dio").finish()
    }
}
#[doc = "DIO"]
pub mod dio;
#[doc = "PMAP"]
pub struct Pmap {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmap {}
impl Pmap {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmap::RegisterBlock = 0x4000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmap::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmap {
    type Target = pmap::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmap {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmap").finish()
    }
}
#[doc = "PMAP"]
pub mod pmap;
#[doc = "CAPTIO0"]
pub struct Captio0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Captio0 {}
impl Captio0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const captio0::RegisterBlock = 0x4000_5400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const captio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Captio0 {
    type Target = captio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Captio0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Captio0").finish()
    }
}
#[doc = "CAPTIO0"]
pub mod captio0;
#[doc = "CAPTIO1"]
pub struct Captio1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Captio1 {}
impl Captio1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const captio1::RegisterBlock = 0x4000_5800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const captio1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Captio1 {
    type Target = captio1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Captio1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Captio1").finish()
    }
}
#[doc = "CAPTIO1"]
pub mod captio1;
#[doc = "TIMER32"]
pub struct Timer32 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer32 {}
impl Timer32 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer32::RegisterBlock = 0x4000_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer32::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer32 {
    type Target = timer32::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer32 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer32").finish()
    }
}
#[doc = "TIMER32"]
pub mod timer32;
#[doc = "DMA"]
pub struct Dma {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dma {}
impl Dma {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma::RegisterBlock = 0x4000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dma {
    type Target = dma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dma").finish()
    }
}
#[doc = "DMA"]
pub mod dma;
#[doc = "PCM"]
pub struct Pcm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pcm {}
impl Pcm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pcm::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pcm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pcm {
    type Target = pcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pcm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pcm").finish()
    }
}
#[doc = "PCM"]
pub mod pcm;
#[doc = "CS"]
pub struct Cs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cs {}
impl Cs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cs::RegisterBlock = 0x4001_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cs {
    type Target = cs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs").finish()
    }
}
#[doc = "CS"]
pub mod cs;
#[doc = "PSS"]
pub struct Pss {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pss {}
impl Pss {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pss::RegisterBlock = 0x4001_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pss::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pss {
    type Target = pss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pss {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pss").finish()
    }
}
#[doc = "PSS"]
pub mod pss;
#[doc = "FLCTL"]
pub struct Flctl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Flctl {}
impl Flctl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flctl::RegisterBlock = 0x4001_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flctl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Flctl {
    type Target = flctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Flctl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flctl").finish()
    }
}
#[doc = "FLCTL"]
pub mod flctl;
#[doc = "ADC14"]
pub struct Adc14 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Adc14 {}
impl Adc14 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc14::RegisterBlock = 0x4001_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc14::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Adc14 {
    type Target = adc14::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Adc14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc14").finish()
    }
}
#[doc = "ADC14"]
pub mod adc14;
#[doc = "System Control Space for ARM core: SCnSCB, SCB, SysTick, NVIC, CoreDebug, MPU, FPU"]
pub struct SystemControlSpace {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SystemControlSpace {}
impl SystemControlSpace {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const system_control_space::RegisterBlock = 0xe000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const system_control_space::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SystemControlSpace {
    type Target = system_control_space::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SystemControlSpace {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SystemControlSpace").finish()
    }
}
#[doc = "System Control Space for ARM core: SCnSCB, SCB, SysTick, NVIC, CoreDebug, MPU, FPU"]
pub mod system_control_space;
#[doc = "RSTCTL"]
pub struct Rstctl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rstctl {}
impl Rstctl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rstctl::RegisterBlock = 0xe004_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rstctl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rstctl {
    type Target = rstctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rstctl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rstctl").finish()
    }
}
#[doc = "RSTCTL"]
pub mod rstctl;
#[doc = "SYSCTL"]
pub struct Sysctl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sysctl {}
impl Sysctl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sysctl::RegisterBlock = 0xe004_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sysctl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sysctl {
    type Target = sysctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sysctl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sysctl").finish()
    }
}
#[doc = "SYSCTL"]
pub mod sysctl;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "TLV"]
    pub tlv: Tlv,
    #[doc = "TIMER_A0"]
    pub timer_a0: TimerA0,
    #[doc = "TIMER_A1"]
    pub timer_a1: TimerA1,
    #[doc = "TIMER_A2"]
    pub timer_a2: TimerA2,
    #[doc = "TIMER_A3"]
    pub timer_a3: TimerA3,
    #[doc = "EUSCI_A0"]
    pub eusci_a0: EusciA0,
    #[doc = "EUSCI_A1"]
    pub eusci_a1: EusciA1,
    #[doc = "EUSCI_A2"]
    pub eusci_a2: EusciA2,
    #[doc = "EUSCI_A3"]
    pub eusci_a3: EusciA3,
    #[doc = "EUSCI_B0"]
    pub eusci_b0: EusciB0,
    #[doc = "EUSCI_B1"]
    pub eusci_b1: EusciB1,
    #[doc = "EUSCI_B2"]
    pub eusci_b2: EusciB2,
    #[doc = "EUSCI_B3"]
    pub eusci_b3: EusciB3,
    #[doc = "REF_A"]
    pub ref_a: RefA,
    #[doc = "COMP_E0"]
    pub comp_e0: CompE0,
    #[doc = "COMP_E1"]
    pub comp_e1: CompE1,
    #[doc = "AES256"]
    pub aes256: Aes256,
    #[doc = "CRC32"]
    pub crc32: Crc32,
    #[doc = "RTC_C"]
    pub rtc_c: RtcC,
    #[doc = "WDT_A"]
    pub wdt_a: WdtA,
    #[doc = "DIO"]
    pub dio: Dio,
    #[doc = "PMAP"]
    pub pmap: Pmap,
    #[doc = "CAPTIO0"]
    pub captio0: Captio0,
    #[doc = "CAPTIO1"]
    pub captio1: Captio1,
    #[doc = "TIMER32"]
    pub timer32: Timer32,
    #[doc = "DMA"]
    pub dma: Dma,
    #[doc = "PCM"]
    pub pcm: Pcm,
    #[doc = "CS"]
    pub cs: Cs,
    #[doc = "PSS"]
    pub pss: Pss,
    #[doc = "FLCTL"]
    pub flctl: Flctl,
    #[doc = "ADC14"]
    pub adc14: Adc14,
    #[doc = "SystemControlSpace"]
    pub system_control_space: SystemControlSpace,
    #[doc = "RSTCTL"]
    pub rstctl: Rstctl,
    #[doc = "SYSCTL"]
    pub sysctl: Sysctl,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            tlv: Tlv::steal(),
            timer_a0: TimerA0::steal(),
            timer_a1: TimerA1::steal(),
            timer_a2: TimerA2::steal(),
            timer_a3: TimerA3::steal(),
            eusci_a0: EusciA0::steal(),
            eusci_a1: EusciA1::steal(),
            eusci_a2: EusciA2::steal(),
            eusci_a3: EusciA3::steal(),
            eusci_b0: EusciB0::steal(),
            eusci_b1: EusciB1::steal(),
            eusci_b2: EusciB2::steal(),
            eusci_b3: EusciB3::steal(),
            ref_a: RefA::steal(),
            comp_e0: CompE0::steal(),
            comp_e1: CompE1::steal(),
            aes256: Aes256::steal(),
            crc32: Crc32::steal(),
            rtc_c: RtcC::steal(),
            wdt_a: WdtA::steal(),
            dio: Dio::steal(),
            pmap: Pmap::steal(),
            captio0: Captio0::steal(),
            captio1: Captio1::steal(),
            timer32: Timer32::steal(),
            dma: Dma::steal(),
            pcm: Pcm::steal(),
            cs: Cs::steal(),
            pss: Pss::steal(),
            flctl: Flctl::steal(),
            adc14: Adc14::steal(),
            system_control_space: SystemControlSpace::steal(),
            rstctl: Rstctl::steal(),
            sysctl: Sysctl::steal(),
        }
    }
}
